package com.lousseief.vault.modelimport com.lousseief.vault.crypto.Conversionimport com.lousseief.vault.crypto.Hmacimport com.lousseief.vault.service.*data class Settings(    var passwordLength: Int = 20,    var categories: MutableList<String> = mutableListOf(),    var savePasswordForMinutes: Int = 2    //var blocksEncoded: Int = 0)class Profile(    val name: String,    var keyMaterialSalt: String,    var verificationSalt: String,    var verificationHash: String,    var iv: String,    var encryptedData: String,    var checkSum: String = "",) {    fun toContentString(): String =        "${keyMaterialSalt}\n${verificationSalt}\n${verificationHash}\n${iv}\n${encryptedData}"    override fun toString(): String =        "${toContentString()}\n${checkSum}"    /**     * @param password - the password to decrypt the vault     * @param vaultManipulation - manipulation of the vault that outputs a new vault     * @param encrypt - flag indicating if the in-memory vault needs to be reencrypted after the call     * @param updatedPassword - if the reencryption of the vault should use a new password instead of the old     *     * @returns the current vault after possible update operations     */    fun accessVault(        password: String,        vaultManipulation: ((vault: MutableVault) -> Vault)? = null,        encrypt: Boolean = false,        updatedPassword: String = password    )    : Vault =        // verify that the correct password is used and if so, return the derived key        VerificationService.authorize(            password, keyMaterialSalt, verificationHash, verificationSalt        )            .let {                Pair(it.sliceArray(0 until 32), it.sliceArray(32 until 64))            }            .also {                (_, hMacKeyBytes) ->                    VerificationService.verify(hMacKeyBytes, toContentString(), checkSum)            }            .let {                (encryptionKeyBytes, hMacKeyBytes) ->                    VaultService.decryptVault(encryptedData, iv, encryptionKeyBytes)                        .let { if (vaultManipulation !== null) vaultManipulation(it) else it }                        .let { vault ->                            if (encrypt) {                                var encryptionKeyBytesToUse = encryptionKeyBytes                                var hmacKeyBytesToUse = hMacKeyBytes                                if(password != updatedPassword) {                                    val (                                        updatedSaltBytes,                                        updatedHashBytes,                                        updatedHashSalt,                                        updatedEncryptionKeyBytes,                                        updatedHmacKeyBytes                                    ) = UserService.createKeyMaterial(updatedPassword)                                    keyMaterialSalt = Conversion.bytesToBase64(updatedSaltBytes)                                    verificationHash = Conversion.bytesToBase64(updatedHashBytes)                                    verificationSalt = Conversion.bytesToBase64(updatedHashSalt)                                    encryptionKeyBytesToUse = updatedEncryptionKeyBytes                                    hmacKeyBytesToUse = updatedHmacKeyBytes                                }                                val (nextIv, nextCipherText) = VaultService.encryptVault(encryptionKeyBytesToUse, vault)                                iv = nextIv                                encryptedData = nextCipherText                                checkSum = Conversion.bytesToBase64(                                    Hmac.generateMac(                                        Conversion.UTF8ToBytes(toContentString()),                                        hmacKeyBytesToUse                                    ))                            }                            vault                        }            }    fun initialize(password: String): Triple<MutableMap<String, Association>, Settings, MutableMap<String, Int>> {        val (fetchedSettings, fetchedAssociationsWithCredentials) = accessVault(password)        val settings = fetchedSettings        val associations = fetchedAssociationsWithCredentials.mapValues { it.value.association }.toMutableMap()        val userNames = fetchedAssociationsWithCredentials            .map {                it.value.credentials                    .map { it.identities }                    .flatten()            }            .flatten()            .groupBy { it }            .mapValues { it.value.size }            .toMutableMap()        /*accessVault(password)            .also {(settings, associations) ->                this.settings = settings                this.associations = associations.mapValues { it.value.association }.toMutableMap()            }*/        return Triple(associations, settings, userNames)    }}